1)  Использование методов getClass(), instance of
Допустим вам нужно написать программу которая рисует фигуры. У каждой фигуры есть свое состояние
Написание кода вида:
        if (figure.getClass() == Line.class) {
            canvas.drawLine(
                    ((Line) figure).getX1(), ((Line) figure).getY1(),
                    ((Line) figure).getX1(), ((Line) figure).getY1()
            );
        } else if (figure.getClass() == Rectangle.class) {
             ...
        } else if (...) {

        }
        ...
Приведет к нарушению принципа OCP, мы не можем расширить код, нам нужно его дописать чтобы он работал с новой фигурой, а
нарушение принципа OCP было по причине нарушения принципа LSP.
Аналогично было бы нарушением использование instance of


2)      Написание кода с наличием слова type
Часто код где есть методы setType(), getType() нарушает принцип LSP. Исключением здесь является использование рефлекции, которая само
собой предполагает извлечение и модификацию метаинформации о классах.
Обычно совместно с этим идет использование enum. Например для примера выше могло бы быть создано перечисление
        enum FigureType {
            LINE, RECTANGLE, ...
        }

и тот же самый код уже будет выглядеть
        if (figure.getType() == FigureType.LINE) {
            canvas.drawLine(
                    ((Line) figure).getX1(), ((Line) figure).getY1(),
                    ((Line) figure).getX1(), ((Line) figure).getY1()
            );
        } else if (FigureType.RECTANGLE) {
            ...
        } else if (...) {

        }
        ...
Это не означает, что нужно избегать использования enum, это означает, что нужно тщательно подумать прежде чем ограничивать
реализации. В enum должны быть константы, которые в будущем не изменяться и не пополняться.



3)     Обращение к свойствам ограничивающим определенное множество объектов.
К примеру, у каждой фигуры замкнутой фигуры есть площадь. Вы решили по разному рисовать фигуры с разной площадью
        if (figure.isClosed()) {
            double s = figure.square();
            if (100 < s && s < 500) {
                // draw red
            } else if (...) {
               ...
            }
        }
Такой код может и не нарушить LSP, если учесть все варианты. Но в таких случаях высока вероятность допустить ошибку.
Будь бдительны. Подумайте не понадобятся ли в дальнейшем посылать в метод объекты с другими свойствами.

Вывод:
1. Если при подстановке нарушается поведение объекта, то это есть нарушение принципа Лисков.
2. Если в коде присутствует адаптация под реализации, то скорее всего код нарушает принцип Лисков.
 Это наблюдение исходит из первого, потому что под определенное поведение нужна определенная проверка.